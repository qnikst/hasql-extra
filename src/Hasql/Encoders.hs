{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE UndecidableInstances #-}
-- |
-- This module provide convenient functions for 'hasql' library.
--
-- The main approach is to use type classes for automatic instances
-- generation:
--
-- @
-- query = HS.Statement sql encoder decoder True where
--   encoder = HE.params @[List of parameters]
--   ...
-- @
--
-- Parameters are autogenerated here, it's not required to pass them
-- but it's strictly advised to do so.
--
-- It order to use your own type in decoder you should provide 'Unnest'
-- instance.
--
-- @
-- instance HE.Unnest '[T.Text, Int32, Maybe HE.JsonbValue, Maybe T.Text] Section where
--   unnest f = HE.Tagged
--     [ HE.unnestNonNullable f sectionName
--     , HE.unnestNonNullable f sectionAt
--     , HE.unnestNullable f (fmap (HE.JsonbValue . Object) . coerce . sectionMetadata)
--     , HE.unnestNullable f sectionDescription
--     ]
-- @
--
-- Functions 'HE.unnestNonNullable' and 'HE.unnestNullable' are used as helpers.
--
-- There are few more helpers:
--
--   * 'enumP'
module Hasql.Encoders
  ( module HE
  , params
  , Unnest(..)
  , unnestNullable
  , unnestNonNullable
  , AsValue(..)
  , AsParams(..)
    -- helper newtypes
  , nullableParam
  , nonNullableParam
    -- newtypes for instances
  , AsJson(..)
  , JsonbValue(..)
    --
  , enumP
  , Tagged(..)
  ) where

import Control.Lens
import Data.Coerce
import Data.Int
import Data.List
import Data.Time.Clock
import qualified Data.Text as T
import qualified Data.ByteString as B
-- import Data.Type.Equality
import Data.Tagged
import qualified Data.Aeson as Aeson

import Fcf
import Fcf.Data.List
import "hasql" Hasql.Encoders as HE

-- | Enum using Prism value.
enumP :: Prism' T.Text a -> HE.Value a
enumP p = HE.enum (^.re p)

-- | Helper function to apply parameters.
-- params :: forall (t::[*]) s (p::[*]) . ((t==p) ~ 'True, AsParams p s) => HE.Params s
params :: forall (p::[*]) s . AsParams p s => HE.Params s
params = unTagged (buildParams @p @s)

-- | Helper for writing simple values, basically it's just a wrapper
-- over the @contramap f ((HE.param.HE.nullable) <HE.encoder>)@
--
nullableParam :: AsValue a => (s -> Maybe a) -> HE.Params s
nullableParam f = contramap f ((HE.param.HE.nullable) value)

-- | Helper for writing simple values, basically it's just a wrapper
-- over the @contramap f ((HE.param.HE.nonNullable) <HE.encoder>)@
--
nonNullableParam :: AsValue a => (s -> a) -> HE.Params s
nonNullableParam f = contramap f ((HE.param.HE.nonNullable) value)

newtype JsonbValue = JsonbValue Aeson.Value

newtype AsJson a = AsJson { getAsJSON :: a }

class AsValue a where value :: HE.Value a
instance AsValue Int32  where value = HE.int4
instance AsValue Int64  where value = HE.int8
instance AsValue T.Text where value = HE.text
instance AsValue Bool   where value = HE.bool
instance AsValue Float  where value = HE.float4
instance AsValue Double where value = HE.float8
instance AsValue B.ByteString where value = HE.bytea
instance AsValue UTCTime where value = HE.timestamptz
instance AsValue JsonbValue where value = contramap coerce HE.jsonb
instance Aeson.ToJSON a => AsValue (AsJson a) where value = contramap (Aeson.toJSON . getAsJSON) HE.jsonb

unnestNonNullable :: (AsValue v, Contravariant f) => (forall z . HE.NullableOrNot HE.Value z -> f z) -> (s -> v) -> f s
unnestNonNullable f g = contramap g ((f.HE.nonNullable) value)

unnestNullable :: (AsValue v, Contravariant f) => (forall z . HE.NullableOrNot HE.Value z -> f z) -> (s -> Maybe v) -> f s
unnestNullable f g = contramap g ((f.HE.nullable) value)

class Unnest (k::[*]) a | a -> k where
  unnest :: forall f . Contravariant f
         => (forall z . HE.NullableOrNot HE.Value z -> f z) -> Tagged k [f a]

data R :: a -> Exp a
type instance Eval (R x) = [x]

data RM :: a -> Exp a
type instance Eval (RM x) = [Maybe x]

instance {-# OVERLAPPABLE #-} (AsValue a, '[a]~k) => Unnest k a where
  unnest f = Tagged [f (HE.nonNullable (value @a))]
instance AsValue a => Unnest '[Maybe a] (Maybe a) where
  unnest f = Tagged [f (HE.nullable (value @a))]

instance (Unnest k1 a, Unnest k2 b, Eval (k1 ++ k2) ~ k) => Unnest k (a,b) where
  unnest f = Tagged $ mconcat
    [ contramap (^._1) <$> (unTagged $ unnest @k1 @a f)
    , contramap (^._2) <$> (unTagged $ unnest @k2 @b f)
    ]
instance {-# OVERLAPPABLE #-} (UnnestArray ks [a], ks ~ k) => Unnest k [a] where
  unnest f = Tagged
    [ f (HE.nonNullable (HE.array a))
    | a <- unnestArray @ks @[a]
    ]
instance (UnnestArray ks [a], Eval (Map RM ks) ~ k) => Unnest k (Maybe [a]) where
  unnest f = Tagged
    [ f (HE.nullable (HE.array a))
    | a <- unnestArray @ks @[a]
    ]

class UnnestArray (k::[*]) a | a -> k where unnestArray :: [HE.Array a]

instance {-# OVERLAPPABLE #-} Unnest k a => UnnestArray k a where
  unnestArray = unTagged $ unnest @k @a HE.element
instance (UnnestArray ks a, Eval (Map R ks) ~ k) => UnnestArray k [a] where
  unnestArray =
    [ HE.dimension foldl' a
    | a <- unnestArray @ks @a
    ]

class AsParams z s | s -> z where
  buildParams :: Tagged z (HE.Params s)
instance {-# OVERLAPPABLE #-} Unnest k a => AsParams k a where
  buildParams = Tagged $ mconcat (unTagged $ unnest @k @a HE.param)
instance (Unnest k1 a, Unnest k2 b, Eval (k1++k2) ~ k) => AsParams k (a, b) where
  buildParams = Tagged $ mconcat
    [ contramap (^._1) (unTagged $ buildParams @k1 @a)
    , (contramap (^._2) (unTagged $ buildParams @k2 @b))
    ]
instance (Unnest k1 a, Unnest k2 b, Unnest k3 c, Eval (Concat [k1,k2,k3]) ~ k) => AsParams k (a, b, c) where
  buildParams = Tagged
     $ contramap (^._1) (unTagged $ buildParams @k1 @a)
    <> contramap (^._2) (unTagged $ buildParams @k2 @b)
    <> contramap (^._3) (unTagged $ buildParams @k3 @c)
instance (Unnest k1 a, Unnest k2 b, Unnest k3 c, Unnest k4 d, Eval (Concat [k1,k2,k3,k4]) ~ k) => AsParams k (a, b, c, d) where
  buildParams = Tagged
     $ contramap (^._1) (unTagged $ buildParams @k1 @a)
    <> contramap (^._2) (unTagged $ buildParams @k2 @b)
    <> contramap (^._3) (unTagged $ buildParams @k3 @c)
    <> contramap (^._4) (unTagged $ buildParams @k4 @d)
instance (Unnest k1 a, Unnest k2 b, Unnest k3 c, Unnest k4 d, Unnest k5 e, Eval (Concat [k1,k2,k3,k4,k5]) ~ k) => AsParams k (a, b, c, d, e) where
  buildParams = Tagged
     $ contramap (^._1) (unTagged $ buildParams @k1 @a)
    <> contramap (^._2) (unTagged $ buildParams @k2 @b)
    <> contramap (^._3) (unTagged $ buildParams @k3 @c)
    <> contramap (^._4) (unTagged $ buildParams @k4 @d)
    <> contramap (^._5) (unTagged $ buildParams @k5 @e)

_test0 :: HE.Params Int64
_test0 = params @'[Int64]
_test1 :: HE.Params (Int64,Int64)
_test1 = params @'[Int64, Int64]
_test2 :: HE.Params (Maybe Int64)
_test2 = params @'[Maybe Int64]
_test3 :: HE.Params (Int64, Maybe Int64)
_test3 = params @'[Int64, Maybe Int64]
_test4 :: HE.Params (Int64, (Int64, Int64)) -- '[Int64, Int64, Int64]
_test4 = params @'[Int64, Int64, Int64]
_test5 :: HE.Params (Int64, (Maybe Int64, Int64))
_test5 = params @'[Int64, Maybe Int64, Int64]
_test6 :: HE.Params [Int64]
_test6 = params @'[ [Int64] ]
_test7 :: HE.Params [[Int64]]
_test7 = params @'[ [[Int64]] ]
_test8 :: HE.Params [(Int64, Int64)]
_test8 = params @'[[Int64], [Int64]]
_test9 :: HE.Params (Int64, [([Int64], Int64)])
_test9 = params -- @'[Int64, [[Int64]], [Int64]]
